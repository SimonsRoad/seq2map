/**
 * @file disp2pts.cpp
 * @author  Johnny Chien <johnny@jjen.cc>
 * @version 1.0
 *
 * @section DESCRIPTION
 *
 * disp2pts converts disparity map to PCL point clouds.
 *
 * Usage:	disp2pts <left_calib> <right_calib> <dp_path> <output_dir> [<im_path>]
 *			-params <matcher> [-binary | -ext <extension> | -gradfilt <grad> | -zmin <zmin> | -zmax <zmax>]
 *
 * Inputs:
 *	left_calib:	Calibrated parameters of the left camera.
 *	right_calib:Calibrated parameters of the right camera.
 *	dp_path:	Path to the disparity files, with extension (e.g. "path/to/disparity/.png".)
 *	output_dir:	Path to the output directory.
 *	im_path:	Optional path to the left images, with extension (e.g. "path/to/images/.png".)
 *				The images are loaded only if gradient filtering is enables.
 *  mather:		Parameter file name generated by the stereo matcher.
 *	extension:	Extension of output file (the default is "pcd")
 *	grad:		Threshold for gradient filtering, applied to remove low-contrast area.
 *  zmin:		Near points clipping boundary.
 *  zmax:		Far points clipping boundary.
 */

#include <algorithm>
#include <boost/program_options.hpp>
#include <boost/unordered_map.hpp>
#include <boost/foreach.hpp>

#include "common.hpp"

using namespace std;
using namespace cv;
using namespace voutils;

struct CalibPaths
{
	Path leftCalib;
	Path rightCalib;

	Mat ReadQ();
};

struct FilterCritera
{
	float zmin;
	float zmax;
	float gradientThreshold;
};

struct Args
{
	Path dpPath;
	Path outDir;
	Path imPath;
	Path dispParamsPath;
	string outExt;
	CalibPaths caPaths;
	FilterCritera filtering;
};
typedef boost::unordered_map<string, Path> FileNameMap;
typedef void (*pointsWriter)(void);
void pcdBinaryPointWriter();
void pcdAsciiPointWriter();

bool parseArgs(int, char*[], Args&, DisparityIO& dpio, pointsWriter&);
FileNameMap makeFileNameMap(const Path& path);
bool checkProjMat(const Mat&);
bool checkProjMat(const Mat&, const Mat&);
Mat dpread(const string& path, uint16_t denorm, double scale);

int main(int argc, char* argv[])
{
	initLogFile("disp2pts.log");

	Args args;
	pointsWriter writer;
	DisparityIO dpio;

	if (!parseArgs(argc, argv, args, dpio, writer)) return -1;
	
	Mat Q = args.caPaths.ReadQ();
	if (Q.empty())
	{
		E_ERROR << "error loading camera parameters";
		return -1;
	}

	FileNameMap imageFiles = makeFileNameMap(args.imPath);
	if (imageFiles.empty() && args.filtering.gradientThreshold > 0)
	{
		args.filtering.gradientThreshold = 0;
		E_WARNING << "gradient check disabled because no image files found";
	}

	try
	{
		Paths files = enumerateFiles(args.dpPath);
		int i = 0;

		BOOST_FOREACH(const Path& file, files)
		{
			Mat dp = dpio.Read(file);
			if (dp.empty())
			{
				E_WARNING << "skipped unreadable file " << file.string();
				continue;
			}

			// convert disparity map to XYZ matrix
			Mat xyz;
			reprojectImageTo3D(dp, xyz, Q);

			// load texture if available
			Path imPath = imageFiles[file.filename().replace_extension().string()];
			Mat im = imPath.empty() ? Mat() : imread(imPath.string());

			// TODO: finish this...
		}
	}
	catch (exception ex)
	{
		BOOST_LOG_TRIVIAL(fatal) << ex.what();
		return -1;
	}

	return 0;
}

bool parseArgs(
	int argc, char* argv[], fs::path& inPath, fs::path& outPath, fs::path& imPath,
	fs::path& leftParamsPath, fs::path& rightParamsPath, fs::path& dispParamsPath,
	string& ext, FilterCritera& filter, pointsWriter& writer)
{
	string in, out, im, caLeft, caRight, disp;
	bool binary;

	namespace po = boost::program_options;
	po::options_description o("Options");
	o.add_options()
		("help,h",	"Show this help message and exit.")
		("gradfilt",po::value<double>(&filter.gradientThreshold)->default_value(0),	"Points having image gradient values lower than the threshold will are considered low contrast region and will be filtered out. Set 0 to disable image contrast filtering. <image_dir> must be specified to enable checking.")
		("zmin",	po::value<double>(&filter.zmin)->default_value(0),	"Minmum depth value. Set -1 to disable near point filtering")
		("zmax",	po::value<double>(&filter.zmax)->default_value(-1),	"Maximum disparity value. Set -1 to disable far point filtering.")
		("params,p",po::value<string>(&disp)->default_value("matcher.yml"),"File name of stereo matching parameters to be read in the <disparity_dir> folder.")
		("ext,e",	po::value<string>(&ext)->default_value("pcd"),		"Extension of point cloud files. Must be one of \"pcd\".")
		("binary,b",po::value<bool>(&binary)->default_value(true),		"Write point data in binary format whenever possible.")
		;

	po::options_description h("hiddens");
	h.add_options()
		("caLeft",	po::value<string>(&caLeft),	"calibrated parameters of left camera")
		("caRight",	po::value<string>(&caRight),"calibrated parameters of right camera")
		("in",		po::value<string>(&in),		"input disparity folder")
		("out",		po::value<string>(&out),	"output points folder")
		("im",		po::value<string>(&im),		"optional input sequence folder");

	po::positional_options_description p;
	p.add("caLeft",1).add("caRight",1).add("in",1).add("out",1).add("im",1);

	bool okay = true;

	po::variables_map vm;
	try
	{
		po::options_description a("all");
		a.add(o).add(h);
		po::store(po::command_line_parser(argc,argv).options(a).positional(p).run(), vm);
		po::notify(vm);
	}
	catch (po::error& pe)
	{
		BOOST_LOG_TRIVIAL(fatal) << "error parsing arguments: " << pe.what();
		okay = false;
	}

	okay &= !vm.count("help");

	if (okay)
	{
		leftParamsPath = caLeft;
		rightParamsPath = caRight;
		inPath = in;
		outPath = out;
		imPath = im;

		if (leftParamsPath.empty())
		{
			BOOST_LOG_TRIVIAL(fatal) << "<left_params> is missing";
			okay = false;
		}
		
		if (rightParamsPath.empty())
		{
			BOOST_LOG_TRIVIAL(fatal) << "<right_params> is missing";
			okay = false;
		}

		if (in.empty())
		{
			BOOST_LOG_TRIVIAL(fatal) << "<disparity_dir> is missing";
			okay = false;
		}

		if (out.empty())
		{
			BOOST_LOG_TRIVIAL(fatal) << "<points_dir> is missing";
			okay = false;
		}

		// writer factory...
		//
		transform(ext.begin(), ext.end(), ext.begin(), tolower);
		if (ext.compare("pcd") == 0)
		{
			writer = binary ? pcdBinaryPointWriter : pcdAsciiPointWriter;
		}
		else
		{
			BOOST_LOG_TRIVIAL(error) << "unknown point file type " << ext;
			okay = false;
		}
	}

	if (!okay)
	{
		cout << "Usage: " << argv[0] << " <left_params.xml> <right_params.xml> <disparity_dir> <points_dir> [<image_dir>] [options]" << endl;
		cout << o << endl;

		return false;
	}

	dispParamsPath = outPath / disp;
	
	return true;
}

bool checkPaths(const fs::path& inPath, const fs::path& outPath, const fs::path& imPath)
{
	bool okay = true;

	if (!directoryExists(inPath))
	{
		BOOST_LOG_TRIVIAL(fatal) << "<disparity_dir> is not readable: " << inPath.string();
		okay = false;
	}

	if (!imPath.empty() && !directoryExists(imPath))
	{
		BOOST_LOG_TRIVIAL(fatal) << "<image_dir> is not readable: " << imPath.string();
		okay = false;
	}

	if (okay && !makeOutDirectory(outPath))
	{
		BOOST_LOG_TRIVIAL(fatal) << "error creating output directory: " << outPath.string();
		okay = false;
	}

	return okay;
}

bool readParams(
	const Path& leftParamsPath, const Path& rightParamsPath, const Path& dispParamsPath,
	Mat& Q, uint16_t& denorm, double& dpscale)
{
	FileStorage fs;

	vector<Mat> P;
	vector<Path> paths;
	paths.push_back(leftParamsPath);
	paths.push_back(rightParamsPath);

    BOOST_FOREACH (const Path& path, paths)
	{
		if (!fs.open(path.string(), FileStorage::READ))
		{
			E_FATAL << "error reading calibration parameters: " << path.string();
			return false;
		}

		try
		{
			Mat Pi;
			fs["P"] >> Pi;
			fs.release();

			if (!checkProjMat(Pi)) throw new exception("P seems to have wrong format");
		}
		catch(exception ex)
		{
			E_FATAL << "error parsing calibration parameters: " << path.string();
			E_FATAL << ex.what();
			return false;
		}
	}
	
	double f = P[0].at<double>(0,0);
	double fv = P[0].at<double>(1,1);
	double uc = P[0].at<double>(0,2);
	double vc = P[0].at<double>(1,2);
	double b0 = -P[0].at<double>(1,4) / f;
	double b1 = -P[0].at<double>(1,4) / f;
	double b = b1 - b0;
	
	Q = b * (Mat_<double>(4,4) << 1, 0, 0, -uc, 0, 1, 0, -vc, 0, 0, 0, f, 0, 0, -1/b, 0);

	if (!fs.open(dispParamsPath.string(), FileStorage::READ))
	{
		E_FATAL << "error reading stereo matching parameters: " << dispParamsPath.string();
		return false;
	}

	try
	{
		fs["denorm"] >> denorm;
		fs["scale"] >> dpscale;
	}
	catch(exception ex)
	{
		E_FATAL << "error parsing stereo matching parameters: " << dispParamsPath.string();
		E_FATAL << ex.what();

		return false;
	}


	return true;
}

FileNameMap makeFileNameMap(const Path& path)
{
	FileNameMap map;
	Paths files = enumerateFiles(path);

	BOOST_FOREACH(const Path& file, files)
	{
		string key = file.filename().replace_extension().string();
		map[key] = file;
	}

	return map;
}

bool checkProjMat(const Mat& P)
{
	if (P.rows != 3 || P.cols != 4) return false;
	if (P.at<double>(0,0) != P.at<double>(1,1)) return false;

	return
		P.at<double>(0,1) == 0 && P.at<double>(1,0) == 0 &&
		P.at<double>(2,0) != 0 && P.at<double>(2,1) == 0 && P.at<double>(2,2) == 1;
}


bool checkProjMat(const Mat& P0, const Mat& P1)
{
	return
		P0.at<double>(0,0) == 0 && P1.at<double>(0,0) == 0 &&
		P0.at<double>(0,2) == 0 && P1.at<double>(0,2) == 0 &&
		P0.at<double>(1,1) == 0 && P1.at<double>(1,1) == 0 &&
		P0.at<double>(1,2) == 0 && P1.at<double>(1,2) == 0;
}


void pcdBinaryPointWriter()
{
}

void pcdAsciiPointWriter()
{
}
